
DISWIN	Windows 逆アセンブラ
-----------------------------------------------------------------------

§概要

  DISWIN は、WindowsのNE(New Executable)フォーマットおよび、PE(Portable
  Executable)フォーマットの実行ファイルを解析するツールです。

  DISWIN.EXE は MS-DOS汎用です。

  ソースを同梱しています。適当なディレクトリに展開し、configureすることに
  より、以下の環境用の実行ファイルを得ることができます。
  ------ 環境 ------ コンパイラ----- 
	 dos . . .  Borland-C++ 4.0  DOS汎用バイナリーを作る.
	 win32 . .  Borland-C++ 4.0  win32(NT Console)
	 win32 . .  gccwin           win32(NT Console)
	 go32  . .  djgpp 1.12       go32   バイナリーを作る.
	 linux . .  gcc
  ==================================

§使い方

＞  DISWIN -Option filename[.EXE .DLL]

§オプション
    -b    セグメント化されたバイナリー(512byteヘッダ付のexe)を出力する
    -s    逆アセンブルソースファイルを出力する
    -h    データセクションを１６進ダンプする。
     -l   -hオプションと併用で、ダンプフォーマットをlong形式にする。
    -u    逆アセンブルリストを大文字で出力
    -e    エントリーテーブルを表示するモード
    -r    リロケーション情報を表示するモード
    -x    ＥＸＰＯＲＴされたエントリーのリストのみ表示する
     -x16  ＥＸＰＯＲＴされたWin16エントリーのリストのみ表示する
     -x32  ＥＸＰＯＲＴされたWin32エントリーのリストのみ表示する
    -v    verbose mode


-----------------------------------------------------------------------
  ＮＥファイルの解析を行なうだけならば、
＞  DISWIN filename[.EXE]   です。
                  .EXEは省略可能、 .DLLは省略不可.
  

-----------------------------------------------------------------------
  ＮＥファイルのＥＸＰＯＲＴされた関数名のみを表示したい場合は、
＞  DISWIN -x filename[.EXE]  です。


-----------------------------------------------------------------------
  ＮＥファイルの解析を行ない、セグメント分割と逆アセンブルまで行なう
  場合は、
＞  DISWIN -b -s filename[.EXE]  と　します。

  この場合、出力結果の保存にかなりのディスク容量を必要とします。
  生成されるファイルは、
  (1) SEG_nn.EXE    . . . セグメント分割されたCODEバイナリー(512byte header付)
  (2) SEG_nn.ASM    . . . セグメント分割されたCODEソース

  (1) (2) は、セグメント分割の数だけ生成されます。

  "SEG_" というファイル名を変えたい場合は、-b または -s の直後に空白をあけずに
  ファイル名前置詞を指定してください。

  例： asm01.asm のような逆アセンブルファイルを出力したい.
＞  DISWIN -sasm filename[.EXE]  と　します。


-----------------------------------------------------------------------
  逆アセンブル結果の中で API 等の呼び出し命令は、
         CALL KERNEL.3
  のように、「モジュール名．エントリー番号」の表記になります。

  DISWIN.EXE と同じディレクトリに DISWIN.API というファイルが存在して
  いる場合、DISWIN.API を読み込んで、「モジュール名．エントリー番号」
  の後ろに、エントリー名を表示させることができます。
  例：
         CALL KERNEL.3 (GETVERSION)
  
  DISWIN.API のフォーマットは次のとおりです。
-----------------------------------------------------------------------
 KERNEL.4	LOCALINIT
（１）行頭に半角空白が必ず１個、
（２）次にモジュール名.序数
（３）タブを１つ入れてエントリー名
-----------------------------------------------------------------------
  DISWIN.API の作成方法は後述します。


§おまけ

  MKLIST.BAT を windows\system ディレクトリに対して実行すると、
  カレントに、DISWIN.API というファイルが生成されます。これは、Windows API
  のエントリー番号 対 関数名　の表なので、生成されたソースの呼び出し番号
  から関数名を知ることができます。
  
  DISWIN.API を、DISWIN.EXE と同じディレクトリに置いておくと、自動的に
  読み込んでデータベースとして参照してくれます。

  生成されるエントリー名は全部大文字になります。これは大文字と小文字を区別
  しないというＭＳの（あるいはＣＰ／Ｍの時代からの）伝統なのです。
  windows.hを参照しながら、手作業か適当なツールを作って、正しい綴りに変える
  と良いでしょう。

  最初はKRNL386.EXEとかUSER.EXEの解析に使おうかと思って作ったのですが、実際
  は、自分で書いたコードの中身を覗くのに重宝します。（コンパイラの癖も掴めま
  すし、アセンブラに落ちるとＣではわからなかった冗長なコードがいやでも目に付
  くようになります。）
  
  また、WindowsがUAE等のエラーを起こした場合、セグメント：オフセットの形式で
  エラー箇所を指摘しますのでその付近のアセンブラコード解析にも使えるようです。
　（普通はターボデバッガで追いかけるのですが、別のマシンでエディタを開いて、
　逆アセンブルコードをじっくり眺めるといった用途があるようです(^_^;;;）

  注意：Windows版 DisWinW では、mklistwのほうをComWinコマンドラインから実行
  してください。  DisWinW.API が生成されます。
  例＞ mklistw c:\windows\system
               ~~~~~~~~~~~~~~~~~  これは貴方がWindowsをインストールした
                                  ディレクトリ(のシステムの方)を指定する

§おまけ・その２

  すこしヘビーなバッチファイルを用意しました。
  DISALL.BAT を実行すると、windows\system ディレクトリにある *.exe *.dll等を
  全部解析します。解析結果はカレントディレクトリの下に dis というサブディレ
  クトリを作成し、さらにその下に各モジュール毎のディレクトリが作られます。
  生成ファイルの量は膨大（約２５０ＭＢ）になりますのでディスク空き容量に注意
  してください。Win16の解析の為には、これを実行する前に、mklist.batを実行して
  diswin.apiを作成しておいたほうが便利です。
  
  例＞ disall  c:\windows\system
               ~~~~~~~~~~~~~~~~~  これは貴方がWindowsをインストールした
                                  ディレクトリ(のシステムの方)を指定する
  副産物として、
  ・winapi16.lst  (Win16 API LIST)
  ・winapi32.lst  (Win32 API LIST)
  ・dis-all.bat   (一括逆アセンブルで使われるバッチ)
  等がカレントディレクトリに残ります。

  mkbat.exe は、ファイルリストの各々のファイルに対して、ある処理(スクリプト)
  を実行するようなバッチコマンドを生成するツールです。やや汎用です。
  sedが使える場合は必要ないかもしれません。使い方は sedより簡単です。

§いいたいこととか

　自分を振り返って見るとMS-DOSのプログラムを作れるようになるまでには、DOS上
のコマンドやDOSそのもの（の一部など）を逆アセンブルして理解する必要があった
ような気がします・・・今でこそ枯れたDOSですが、8bit CPUや BASICからDOSに移る
ときはかなりの戸惑いがあったはずです。自分はまだWINDOWSのプログラムらしいプ
ログラムを作れないのですが、やはりWINDOWSを理解していないのが原因のような気
がします。このプログラムがWINDOWSを理解する第一歩になるといいな、という気持
ちで制作しました。これからのWINDOWSはさらなる複雑化の一途をたどると思われま
すが、基本のところはWINDOWS 2.11のころからあまり変わってないような気がします。

ところで、WINDOWS 2.11なんて、全く使う気持ちの起きない代物でした。 今でこそ
640kBより上のメモリーをまともに使えて、まがりなりの仮想記憶を備えて、ビデオ
アクセラレータが発達して、フリーウェアなどのソフトウェア環境が 充実してきた
かな？というところです。

　ＭＳ-ＤＯＳの内部解析本はいくつか出版されましたが、WINDOWSの内部解析の本
は、ほとんどありません。WINDOWSは、公開されたAPI の仕様だけを見てプログラミ
ングできるような、理想的なＯＳではありません。ある意味ではＭＳＤＯＳ以上に
泥臭く、脆弱で、クセが強い環境であると思います。（そこがまた、面白いのかも
知れません）



§バグなど

　過去のバージョンは、セグメント分割数が２０を越えるあたりで、ファイルの
オープンに失敗する問題を抱えていました。本バージョンではこの問題はありません。

  逆アセンブラの部分は、最小限の命令しかサポートしていません。プレフィックス
の正しい処理、0x0fで始まる命令、８０３８６以降の３２ビットモードの命令、0x66
,0x67が前置される３２ビット長の命令、浮動小数点命令、等は未処理です。

  プレフィクスが２つ以上並ぶ場合、プレフィックス表示が抜けるバグがありますの
で、とりあえずＨＥＸ表示に注意しながらソースを読んでください。

  リロケーションテーブルの情報は、まだ、完全に生かし切れていないので、
インポート関数の呼び出しを参照している場合に限り正しくリロケーション
しているようですが、それ以外のリロケーション情報は結果に反映されません。

  今回のバージョンでは、ComWin用のWinMain.cとWinMain.hを加えてmakeすれば
Windows(COMWIN)上でも動作するDiswinW.exeが作れるようになっています。
但しDiswinW.exeを利用するときはdiswin.apiをdiswinw.api にリネームする必要が
あります。

  注釈
  ----------------------------
  COMWIN とは、[ Command Manager for Window System ]（前寺氏 作）のことです。
  Windows 3.1上で使える端末エミュレータ＆ＤＯＳプロンプトエミュレータです。
   （un*xのＸ窓の中で使えるxtermのようなものと思ってください。
     しかしshellとcommand.comの機能もありますし drag & drop機能もありますので
     ただの端末だと思ったら大違いですが・・・
   ）

  Ｗｉｎ３２(s)用のＰＥ形式も逆アセンブルできるようになりましたが、今のところ
  エントリー名やシンボル情報は表示されません。
                             （Ver0.09で、表示するようにしました）
  コードセクションのサイズに制限はありません。

  ＰＥ形式は、ちょっと覗いた感じではSystem-V UN!Xの COFF を取り入れた形式の
  ように見えますが、UN!Xと互換性があるようには到底思えません。やはり独自流の
  フォーマットだと思います。（巧妙なツールを組めば、UN!XのCOFF部分だけ取り出
  すことはできるかもしれませんが、動作するわけではないので無意味です）
  ただ、似ていることは確かなので、COFF出力できるUN!Xのコンパイラの出力をなん
  らかのコンバータに通すことでＰＥ形式を作成することができなくもないかもしれ
  ません。（そうする価値があるかどうかは別問題として）

  と、書きましたが、現時点(96.01.25)で何とPE形式を出力できるgccが存在してい
  ます。(NIFty fextにも転載されています.) 簡単なサンプルが付いていますが、
  GUIなアプリも書こうと思えば書けるようになっています。ブラボ〜
  （http://www.cygnus.com ＝ gccwinを保守しているCygnus Supportのアドレスです）

  しかし、diswin.exe は、相変わらず Pure DOS アプリなので実行環境を選びません。
  （なんのこっちゃ？）

  configure.bat を使用して、再構成する場合の問題点を記しておきます。
******************* configure の使い方 ***************************
* configure dos . . .  Borland-C++ 4.0  DOS汎用バイナリーを作る.
* configure win32 . .  Borland-C++ 4.0  win32  バイナリーを作る.
* configure gccwin  .  gccwin           win32  バイナリーを作る.
* configure go32  . .  djgpp 1.12       go32   バイナリーを作る.
* configure linux . .  for linux diswin!
******************************************************************
  configureの使い方は、後ろにdos/win32/gccwin/go32/linuxのいずれかを指定する
  だけですが、

  ・Win95など、ロングファイルネームの使える環境では、configureと打っても起動
    しません。configur と打つか、configur.bat をconfigure.batにリネームして
    から起動してください。
  ・gccwin環境では、make cleanが正しく動きませんので、手動で*.oを消去したのち
    makeしてください。
  ・gccwin環境では、なぜか<malloc.h>がありません。includeディレクトリに
    #include <stdlib.h>
    の１行を入れたmalloc.hを置いてみてください。
  ・linux にソースを持って行く場合、DOSの改行コード(CR+LF)からCRを取り去る
    必要があります。（適当なエディタかフィルターを使ってください）
    （Ｃのマクロ文の後ろにある＼(バックスラッシュ)がエラーに引っかかります）

§配布条件

  自由に配布していただいて構いません。
　改良したものを配布する場合は、できるだけソースを添付されることを希望します。

　このプログラムを使用したことによって起こるいかなる結果に対しても制作者は責
を負いません。あくまでも使用者責任において運用してください。

  バグ、不具合等は指摘してくだされば修正できる場合があります。
ソースリストを公開していますので、修正された差分ファイルをお送りいただけると
次回バージョンに反映させることができます。

§謝辞

  ＪＡＧＡＲＬさんより、MMX命令の解析部分のソースをお寄せ頂きました。
  さっそくVer0.13 にて反映させて頂きました。どうもありがとうございます。
  (JAGARLさんのパッチMMX.PATは、ver1.3のソースですでに反映済です)

§改版履歴

 0.03	・リロケーションチェインの手繰りでループに陥るバグをフィクス
 	・internal fixupのセグメント：オフセットが正しく表示できるようにした
 	・fs: gs: 0x66 0x67 のプレフィクスを一応処理した。

 0.04   ・浮動小数演算命令の一部を扱うようにした。
 　　 　・0x0fで始まる命令の一部を扱うようにした。

 0.05	・浮動小数演算命令のレパートリーを増やした。
 	・mklistでできるファイルのタブが抜けていてうまく取り込めない
 	　バグを直した。
	・Borland-C等で -M オプションを付けてコンパイルすると生成される、
	  *.mapファイルが*.exeと同じディレクトリに存在すれば、それを読み込ん
	  でラベルシンボルとして表示するようにした。
	・ <dos.h>  に依存した書き方(FP_OFFやMK_FP)を改め、ComWinでも動作する
	　ように修正した。
	・プログラム終了時点で残りヒープや文字列バッファの使用状況の表示を
	　入れた。
	・16:16 の PTR TYPE 以外に、SEG OFFSETのみのFIXUP情報も反映できるよう
	　にした。
 0.07   ・Ｗｉｎ３２(s)の 'PE' (Portable Executable)形式の実行ファイルにも
	　コードサイズ６４ｋＢの制限つきながら対応した。
	・INTERNAL FIXUP (SEGのみ) の情報にも対応した。
 0.08   ・'PE'のコードセクション６４ｋＢの制限を取り外した。
 0.09   ・'PE'の .idata .edata セクションを解析してテーブル表示とシンボル情報
          を反映させるようにした。
 0.10   ・shld shrd 等の命令を追加。コード解析のいくつかのバグ取りを行なった。
        ・.idataセクションの先頭にインポートヘッダーが無い形式(?)に対応した。
 0.11   ・configure.bat により、各種環境に対応。
        ・ヘキサダンプ(.dataセクション)を入れた。
 0.12   ・'PE'形式のファイルでまれにインポートテーブルが解読できないことがある
 　　　　 というBugをFix。
        ・命令コードの説明コメントをREM文で挿入できるようにしました。
        ・UNDOCUMENTED-PCに書かれていたいくつかのインテル未公開命令も逆アセン
        　ブルするようにしました。
        ・戯れに、ヘッダー無しの80286(use16)バイナリー,80386(use32)バイナリー
        　コードを解析するオプション -c<adrs> 、-d<adrs> を追加しました。
          BIOS ROMの解析などにどうぞ。
        ・これまたおまけですが、'LE'もほんのすこしサポートはじめてます。
 0.13   ・JAGARLさんより頂いた、MMX命令の解析部分を組み込みました。
 0.14   ・3DNow!の逆アセンブルが比較的うまく行ったので組み込んでみました。

